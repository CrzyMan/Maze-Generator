<!DOCTYPE html>

<html>
    <head>
        <title>Maze Generator</title>
        <style>
            
            span.canvas {
                padding-left: 0;
                padding-right: 0;
                margin-left: auto;
                margin-right: auto;
                display: block;
                position: relative;
                width: 800px;
            }
            
            td {
                border: solid;
                padding: 5px;
                padding-left: 10px;
                padding-right: 10px;
                margin: 3px;
            }
            
            canvas {
                border: solid;
                position: absolute;
                top: 0px;
                
            }
        </style>
    </head>

    <body>
        
        <table>
            <tr>
                <td>
                    <input id="r_c" type="range" min=10 max=30 value=10 /><br/>Columns : <span id="s_c">10</span>
                </td>
                <td>
                    <input id="r_r" type="range" min=10 max=30 value=10 /><br/>Rows: <span id="s_r">10</span>
                </td>
                <td>
                    <button id="b_g">New Game</button><br/>
                    Animation: <input type="checkbox" id="i_a">
                </td>
                <td>
                    <span style="font-weight: bold; font-size: large;">Game Mode</span><br/>
                    <input type="radio" value=0 name="gameMode" checked=true> FreeMode
                    <input type="radio" value=1 name="gameMode"> Timed
                    <input type="radio" value=2 name="gameMode"> Points
                </td>
            </tr>
        </table>
        
        <script type="text/javascript">

/*
 * TODO: Click green square, it follows the mouse.
 *
 * TODO: assign score by time and difficulty
 *    - maybe: ( rows * columns ) / time
 *
 * TODO: Different modes
 *    - Timed: See how many points you can get in a certain amount of time
 *    - Freemode: Just keep going
 *    - Points: See how quickly you can reach a certain number of points
 *    - setup(), update(), isDone()
 */

// other variables
var grid, dx, dy, columns, rows, reqAnimId, mouseX, mouseY;

// For easy reference to relative direction (0: up, 1: right, 2: down, 3: left)
var directions = [[0,1],[1,0],[0,-1],[-1,0]];
// Add the maze canvas
var c_maze = document.createElement('canvas');
c_maze.c = c_maze.getContext('2d');
c_maze.height = 800;
c_maze.width = 800;
c_maze.style.zIndex = 1;

// Add block canvas
var c_block = document.createElement('canvas');
c_block.c = c_block.getContext('2d');
c_block.c.fillStyle = "red";
c_block.height = 800;
c_block.width = 800;
c_maze.style.zIndex = 2;
c_maze.onmousemove = function(e){
    mouseX = e.offsetX;
    mouseY = e.offsetY;
};

(function(){
    var d = document.createElement('span');
    d.appendChild(c_maze);
    d.appendChild(c_block);
    document.body.appendChild(d);
    d.className = "canvas";
})()


// set-up DOM inputs
var s_c = document.getElementById('s_c');
var r_c = document.getElementById('r_c');
r_c.onmousemove = function(){ s_c.innerHTML = columns = r_c.value; };

var s_r = document.getElementById('s_r');
var r_r = document.getElementById('r_r');
r_r.onmousemove = function(){ s_r.innerHTML = rows = r_r.value; };

var b_g = document.getElementById('b_g');
b_g.onclick = function(){
    generate();
};

var i_a = document.getElementById('i_a');
var animation = false;
i_a.onchange = function(){
    animation = i_a.checked;
}


/*
 * Generates the maze
 *
 * int columns , number of columns in the maze
 *
 * int rows , number of columns in the maze
 *
 * return void
 */
function generate(){
    
    cancelAnimationFrame(reqAnimId);
    
    // Keep the columns and rows within bounds
    columns = columns >= 10 ? (columns <= 30 ? ~~columns : 30) : 10;
    rows = rows >= 10 ? (rows <= 30 ? ~~rows : 30) : 10;
    
    
    // empty and then fill the the grid
    grid = [];
    for (var i = 0; i < columns; i++){
        grid.push(new Uint8Array(rows));
    }
    
    // Empty the stack
    pathStack = [];
    
    // clear and then draw the grid
    c_maze.c.clearRect(0,0,c_maze.width,c_maze.height);
    c_maze.c.lineWidth = 1;
    dx = c_maze.width / columns;
    dy = c_maze.height / rows;
    c_maze.c.beginPath();
    for(var i = 0; i < columns; i++){
        c_maze.c.moveTo(~~(dx*i)+0.5, 0);
        c_maze.c.lineTo(~~(dx*i)+0.5, c_maze.height);
    }
    for(var i = 0; i < rows; i++){
        c_maze.c.moveTo(0, ~~(dy*i)+0.5);
        c_maze.c.lineTo(c_maze.width, ~~(dy*i)+0.5);
    }
    c_maze.c.closePath();
    c_maze.c.stroke();
    
    // set starting point
    var sx = randInt(columns-1);
    var sy = randInt(rows-1);
    //grid[sx][sy] = 1;
    pathStack.push([[sx, sy],null]);
    
    if (animation)
        runMazeGen();
    else
        while (stepMazeGenerate() == true){}
    
    c_block.c.fillStyle = "lime";
    c_block.c.fillRect(5,  5, dx - 10, dy - 10);
    c_maze.c.fillStyle = "red";
    c_maze.c.fillRect((columns-1)*dx + 5, (rows-1)*dy + 5, dx - 10, dy - 10);
    
    grid = [];
}

function runMazeGen(){
    if (stepMazeGenerate() == true)
        reqAnimId = requestAnimationFrame(runMazeGen);
}


// Stack to hold all of the possible paths ([[to],[from]])
var pathStack = [];

/*
 * Performs the next step in making the maze
 *
 * return Boolean , whether the step was executed or not (if not, the maze is done!)
 */
function stepMazeGenerate(){
    // Clear background canvas
    c_block.c.clearRect(0, 0, c_block.width, c_block.height);
    
    // Return false if the stack is empty
    if (pathStack.length == 0) return false;
    
    // Grab the reference ([current],[came from])
    var ref = pathStack.pop();
    
    // Draw spot where we are
    c_block.c.fillStyle = "lime";
    c_block.c.beginPath();
    c_block.c.rect(ref[0][0]*dx + 5, ref[0][1]*dy + 5, dx - 10, dy - 10);
    c_block.c.fill();
    c_block.c.closePath();
    
    if (ref[1] != null){
        // Make sure the position just arrived from is flagged as visited
        grid[ref[1][0]][ref[1][1]] = 1;
        
        // Erase the wall in the correct direction
        if (grid[ref[0][0]][ref[0][1]] == 0){
            eraseWall(ref[0], ref[1])
        }
        
        // Flag current position as visited
        grid[ref[0][0]][ref[0][1]] = 1;
    }
    
    
    
    // Produce potential moves
    var options = [];
    for (var i = 0; i < directions.length; i++){
        var nx = ref[0][0]+directions[i][0];
        var ny = ref[0][1]+directions[i][1];
        
        // if the new position is within the grid, and hasn't been visited yet
        if (nx >= 0 && nx < columns && ny >= 0 && ny < rows && grid[nx][ny] == 0){
            //           [newX, newY]
            options.push([nx, ny]);
        }
    }
    
    // Pick a move to do
    var move = options.length > 0 ? ~~(Math.random()*options.length) : -1;
    
    // if there is a move to be made
    if (move != -1){
        
        // Add the moves to the stack, the selected one last
        for(var i = 0; i < options.length; i++){
            if (i != move)
                pathStack.push([options[i], ref[0]]);
        }
        pathStack.push([options[move], ref[0]]);
    }
    
    return true;
}


/*
 * Produce random integer inclusively between the min and max
 *
 * int max , maximum value that the randInt() may return
 *
 * int min , minimum value that the randInt() may return
 *
 * return random integer inclusively between max and min
 */
function randInt(max, min){
    min = ~~min || 0;
    max = ~~max || 0;
    return ~~(min + (Math.random()*max - min + 1));
}


/*
 * Erases the wall between to blocks
 *
 * int[] to , [x, y] the grid space the generator is going to
 *
 * int[] from , [x, y] the grid space the generator is coming from
 *
 * return void
 */
function eraseWall(to, from){
    // supposing that to and from are neighbors
    var mx = ((to[0] + from[0])*dx) >> 1;
    var my = ((to[1] + from[1])*dy) >> 1;
    var w = (((to[0] + from[0] + 2)*dx) >> 1) - mx;
    var h = (((to[1] + from[1] + 2)*dy) >> 1) - my;
    c_maze.c.clearRect(mx + 1, my + 1, w - 1, h - 1);
}
/* */





/* NOW FOR GAMEPLAY! */
var gameLogic = []

// Add all the gamemodes

// FreeMode
gameLogic.push({
    name: "Free-mode",
    
    setup: function(){
        generate();
        this.update();
    },
    
    update: function(){
        
    },
    
    isDone: function(){
        this.setup();
    }
})



// the block
block = {
    x: 0,
    y: 0,
    
    move: function(){
        // vel is normalize position to mouse, scale by speed
        // check for walls (pixels in a line in the cardinal directions)
        // move by vel
    },
    
    hasWon: function(){
        // check if the bounds are intersecting with the red square
    }
}

        </script>
    </body>
</html>
